channel c.
free SI: channel.
free ID: channel[private].
free IA: channel[private].
free DA: channel[private].
free ST: channel[private].
free IT: channel[private].

type id.
type mkp.
type skp.
type ski.

fun pk(skp): mkp.

fun encIBE(mkp, id, bitstring) : bitstring.
fun getSki(skp, id): ski.
reduc forall x:bitstring, iid: id, mkey: skp, y: ski;
  decIBE(encIBE(pk(mkey), iid, x), getSki(mkey, iid)) = x.

(*
 *  EVENTS
 *
*)

event endS().
event endICJ().
event endDecAuth().
event endA().
event decryptionStarted(bitstring).
event decryptionReceived(bitstring).
event auditorBullet(bitstring, bitstring).

event KOt(bitstring, id, bitstring, id, bitstring).
event KOt'(bitstring, id, bitstring, bitstring).
event OKt(bitstring, id, bitstring, id, bitstring).
event OKt'(bitstring, id, bitstring, bitstring).

(*
 *  QUERIES
 *
*)
query event (endS()).
query event (endICJ()).
query event (endDecAuth()).
query event (endA()).

query data:bitstring, host:id, data':bitstring, ct:bitstring;
  event (KOt'(data, host, data', ct));
  event (OKt'(data, host, data', ct)).

query a:bitstring;
  event (decryptionReceived(a)) ==> event (decryptionStarted(a)).

(* data Source *)
let pS(mpk:mkp) =
  new data: bitstring;
  new host: id;
  out(ST, (data, host));
  event decryptionStarted(data);
  out(SI, (encIBE(mpk, host, data), host));
  event endS().

(* Investigator, Judge, Court *)
let pICJ =
  in(SI, (ct:bitstring, host: id));
  out(IT, (ct, host));
  out(IA, (ct, host));
  out(ID, (ct, host));
  in(ID, skeyi:ski);
  let x = decIBE(ct, skeyi) in
    event decryptionReceived(x);
  event endICJ().

let decAuth(skey:skp) =
  out(c, pk(skey));
  in(ID, (ct:bitstring, host:id));

  out(DA, (ct, host));
  in(DA, exists:bool);
  if exists then
    out(ID, getSki(skey, host));
  event endDecAuth().

  (* get input
  output event
  output public
  output for test *)
(* Auditor *)
let pA =
  in(IA, (ct:bitstring, host:id));
  in(DA, (ct':bitstring, host':id));
  if (ct <> ct') && (host<> host') then
    out(DA, false)
  else
    out(DA, true);
  event auditorBullet((ct, host), (ct', host'));
  event endA().

(* Tester *)
let pT(skey:skp) =
  in(ST, (data:bitstring, host:id));
  in(IT, (ct:bitstring, =host));

  let data':bitstring = decIBE(ct, getSki(skey, host)) in
  if data <> data' then (*)&& host <> host' then*)
    event KOt'(data, host, data', ct)
  else
    event OKt'(data, host, data', ct);
  0.

process
	! new skey:skp ;(
	! out(c, pk(skey))  | pA() | decAuth(skey) | pICJ() | pS(pk(skey)) | pT(skey)
	)
